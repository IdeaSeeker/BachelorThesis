\section{Создание отчёта по сгенерированным тестам}

Результатом работы любого статического анализатора является некоторый отчёт. Иначе говоря, список обнаруженных ошибок вместе со всей дополнительной информацией, которая может помочь программисту разобраться в проблеме быстрее.

Таким образом, первая задача, которая решается в данной работе "--- создание такого отчёта по имеющимся данным, а именно по сгенерированным инструментом UnitTestBot тестам. Причём наибольший интерес вызывают тестовые случаи, приводящие к падению программы, то есть к выбрасыванию необработанных исключений. Следовательно, сообщение об ошибке должно содержать конкретное место в коде, где возникает исключение, а также путь исполнения, который к нему приводит.

\subsection{Формат SARIF}

В качестве формата отчёта был выбран SARIF (Static Analysis Results Interchange Format) \cite{sarif}. Это формат на основе JSON \cite{json}, созданный специально для единообразного описания результатов статического анализа. Принят как стандарт OASIS\footnote{Organization for the Advancement of Structured Information Standards) "--- глобальный консорциум, который управляет разработкой, конвергенцией и принятием промышленных стандартов электронной коммерции в рамках международного информационного сообщества.} и используется во многих популярных инструментах.

Рассмотрим структуру формата, а также основные возможности для описания ошибок, которые он предоставляет. Легче всего это сделать на примере небольшого отчёта, который приведён ниже (для краткости все незначащие детали заменены на многоточие).

\begin{zerocode}
{
  "schema" : "https://.../sarif-schema-2.1.0.json",
  "version" : "2.1.0",
  "runs" : [
    "tool" : { ... },
    "results" : [ {
      "ruleId" : "...",
      "level" : "error",
      "message" : { "text" : "..." },
      "locations" : [ ... ],
      "relatedLocations" : [ ... ],
      "codeFlows" : [ ... ]
    } ]
  ]
}
\end{zerocode}

На самом верхнем уровне формат определяет \var{runs} "--- список результатов различных запусков анализатора.

Каждый запуск содержит в себе \var{tool} "--- некоторая информации об инструменте и \var{results} "--- непосредственно список обнаруженных ошибок.

Один результат описывается ключами 

\begin{itemize}
    \item \var{ruleId} "--- уникальный идентификатор для данного типа ошибки.
    \item \var{level} "--- уровень серьезности дефекта, например, \verb|error| или \verb|warning|.
    \item \var{message} "--- сообщение, которое будет показано пользователю.
    \item \var{locations} "--- список мест в коде, где была найдена ошибка. Каждый отдельный \var{location} имеет собственное внутреннее устройство, о котором рассказано ниже.
    \item \var{relatedLocations} "--- список мест в коде, каким-либо образом связанных с ошибкой. Элементами списка являются те же объекты \var{location}.
    \item \var{codeFlows} "--- список путей, по которым прошла программа, прежде чем наткнуться на обнаруженный дефект.
\end{itemize}

Объект \var{location} состоит из пути до файла \var{artifactLocation} и позиции внутри файла \var{region}. Пример объекта \var{location} представлен ниже.

\begin{zerocode}
"physicalLocation" : {
  "artifactLocation" : {
    "uri" : "src/examples/Main.java"
  },
  "region" : {
    "startLine" : 91,
    "startColumn" : 9,
    "endLine": 91,
    "endColumn": 20
  }
}
\end{zerocode}

Как уже отмечалось ранее, SARIF имеет неплохую поддержку в сфере анализа программ. В частности, смотреть отчёт в удобном виде, с навигацией по коду и другими полезными функциями, можно в редакторе Visual Studio Code \cite{vscode}. Также есть интеграция с CI/CD платформы GitHub \cite{sarif-git}, что может быть удобно для больших команд разработчиков.

\subsection{Извлечение информации из тестов}

Теперь опишем, как именно разработанный модуль формирования отчётов получает нужную информацию об ошибках по результатам символьного исполнения.

После того как UnitTestBot отработал на пользовательском коде и сгенерировал для него тесты, модуль смотрит на набор найденных терминальных состояний, другими словами, на тестовые случаи. При этом он будет рассматривать только те состояния, которые приводят к выбрасыванию исключения.

В терминальном состоянии \var{state} содержится достаточно много полезной информации. Во-первых, в там хранится результат исполнения, в нашем случае это тип возникающего исключения. Во-вторых, конкретные входные данные анализируемого метода, полученные из SMT-решателя. Зная это, модуль формирует сообщение об ошибке по шаблону ниже.

\begin{zerocode}
"Unexpected ArithmeticException: / by zero.
 Test case: example(28, -1)."
\end{zerocode}

В данном случае было найдено деление на ноль при запуске метода \var{example} с аргументами $28$ и $-1$.

В \var{state} также содержится путь из инструкций \var{path}, по которому машина пришла в это состояние. Она работает с трёхадресным Java байт-кодом, однако внутри UnitTestBot есть механизм, который по любой инструкции может вернуть номер соответствующей строчки в исходном коде.

Чтобы восстановить номер строки с ошибкой \var{startLine}, достаточно взять последний элемент из списка \var{path}. Далее, модуль считывает строку с номером \var{startLine} из файла с кодом пользователя и вычисляет \var{startColumn} и \var{endColumn}, обрезая пробельные символы с начала и с конца. Таким образом, формируется поле \var{location} в отчёте.

Поле \var{codeFlows} также восстанавливается из значения \var{path}. Модуль анализирует граф вызовов методов на пути \var{path} и назначает для каждого уровня вложенности последнюю на этом уровне инструкцию. Полученный список номеров строк оказывается равен настоящей трассировке стека, как если бы мы просто запустили код с найденными входными аргументами, то есть ровно то, что и требовалось.

Последнее, что фиксируется в отчёте "--- это поле \var{relatedLocations}. В него помещается ссылка на соответствующий данному результату тест в файле со сгенерированными тестами. Когда стартует разработанный модуль, UnitTestBot уже записал тесты в выходной файл, а значит можно просто найти позицию нужного теста по его имени в этом файле.

В итоге вся собранная информация структурируется и сериализуется в JSON.

% можно ещё добавить про минимизацию результатов

\subsection{Пример работы}

Модуль поддерживает все стандартные исключения Java, в том числе и \verb|AssertionError|, поэтому, один из типичных способов использования инструмента выглядит следующим образом. Программист сначала расставляет \verb|assert| проверки в коде, если хочет гарантировать выполнение некоторых инвариантов. После чего он запускает разработанный статический анализатор, который выявляет все места, где проверки не проходят.

Рассмотрим пример его работы на функции \var{abs}, которая, как понятно из названия, должна возвращать модуль числа. Её возвращаемое значение обязано быть не меньше нуля, и, чтобы это гарантировать, в методе присутствует строчка \verb|assert x >= 0|.

\begin{code}
public class Main {
    int abs(int x) {
        if (x < 0) {
            x *= -1;
        }
        assert x >= 0;
        return x;
    }
}
\end{code}

Однако UnitTestBot обнаружил, что передача числа $-2^{32}$ приводит к \verb|AssertionError| (происходит переполнение типа \verb|int|), что и отражено в сформированном отчёте SARIF. Он получился достаточно большим (около 100 строк), поэтому для краткости я перечислю в здесь только значения важных полей без сохранения структуры формата SARIF.

\begin{itemize}
    \item Сообщение об ошибке:

\begin{zerocode}
"message" : {
  "text" : "Unexpected AssertionError.
            Test case: abs(-2147483648)"
}
\end{zerocode}

    \item Местоположение ошибки:

\begin{zerocode}
"uri" : "src/Main.java",
"region" : {
  "startLine" : 6,
  "startColumn" : 9
}
\end{zerocode}

    \item Местоположение сгенерированного теста:

\begin{zerocode}
"uri" : "utbot_tests/MainTest.java",
"region" : {
  "startLine" : 29,
  "startColumn" : 5
}
\end{zerocode}

    \item Трассировка стека:

\begin{zerocode}
[
    "MainTest.testAbs3(MainTest.java:34)",
    "Main.abs(Main.java:6)"
]
\end{zerocode}

\end{itemize}
