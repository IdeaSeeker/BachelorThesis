\section{Тестирование и эксперименты}

В данной главе будут описаны результаты тестирования разработанного статического анализатора на различных проектах. Эксперименты проводились с целью проверки качества полученного программного продукта. Причём под качеством подразумевается не только количество и серьёзность обнаруживаемых им дефектов, но и простота настройки и запуска, а также удобство использования инструмента в целом.

Замеры производительности не осуществлялись и не были целью тестирования, однако для лучшей воспроизводимости полученных результатов, укажем технические характеристики ноутбука, на котором оно проводилось.
\begin{itemize}
    \item \verb|OS| "--- \verb|Windows 10, 64-bit|
    \item \verb|CPU| "--- \verb|Intel(R) Core(TM) i5-8665U CPU @ 1.90GHz|
    \item \verb|RAM| "--- \verb|16 ГБ|
\end{itemize}

Всё взаимодействие с настройкой, запуском и результатами анализатора происходило исключительно средствами модифицированного в данной работе плагина для IntelliJ IDEA. Для всех примеров было выставлено ограничение по времени на анализ кода в 60 секунд на один класс.

\subsection{Тестирование taint-анализа}

В ходе экспериментов сравнивалась эффективность нахождения уязвимостей между инструментом SpotBugs и техникой taint-анализа, реализованной в данной работе. Конкретнее, для сравнения были выбраны следующие метрики.
\begin{itemize}
    \item Общее количество найденных проблем.
    \item Доля обнаруженных ошибок от общего числа дефектов в программе.
    \item Доля ложноположительных срабатываний от общего числа обнаруженных проблем.
\end{itemize}

В качестве тестов, на которых проводились замеры, была взята часть проекта Juliet Java \cite{juliet} "--- набора синтетических программ, в которых содержится более 100 различных типов уязвимостей CWE. Все программы распределены по разделам в соответствии с названием допущенной в них ошибки. Для тестирования алгоритмов taint-анализа был выбран раздел с SQL-инъекциями, в котором находится 3660 классов и 2220 специально сделанных ошибок. 

В тестовых данных все допущенные ошибки размечены, то есть для каждого класса известна находящаяся в нём уязвимость, а также её местоположение в коде. Таким образом, требовалось запустить анализаторы и сравнить полученные наборы предупреждений с правильным.

Результаты запусков представлены в таблице \ref{taint-results}. 

\begin{table}[ht]
\begin{center}
\begin{tabular}{lccc}
    & UnitTestBot & SpotBugs \\
\hline
    Обнаружено проблем     & 1023 & 5280  \\
    Верно найденных ошибок & 46\% & 100\% \\
    Ложных срабатываний    & 0\%  & 58\%  \\
\end{tabular}
\caption{
\label{taint-results} Результаты запуска на тестовом наборе Juliet Java.}
\end{center}
\end{table}

Модифицированный UnitTestBot смог найти 1023 SQL-инъекции, что составляет 46\% из всех допущенных в наборе ошибок. При этом не было выдано ни одного ложноположительного срабатывания. 
Оставшиеся 54\% не были найдены, в основном, по той причине, что инструменту не удалось сгенерировать ни одного теста за предоставленное ему время. В частности, использование массивов или длинных строк в анализируемых программах значительно замедляет реализованное в UnitTestBot символьное исполнение. Ускорение его работы является одним из наиболее приоритетных направлений для исследования в будущем.

SpotBugs обнаружил все 100\% уязвимостей, однако вместе с этим нашёл ещё 3060 несуществующих проблем, что почти в полтора раза больше, чем общее число реальных ошибок в программах (2220). Таким образом, его частота ложных срабатываний составила 58\%.

Полученные результаты показывают, что разработанный модуль taint-анализа позволил инструменту UnitTestBot находить уязвимости вида SQL-инъекция практически в половине случаев на соответствующем тестовом наборе. Отметим, что до модификации UnitTestBot был в принципе не применим к данной задаче.

\subsection{Запуск на реальных проектах}

С целью показать способность инструмента анализировать не только синтетические программы, но и большие объёмы реального кода, было проведено тестирование на нескольких популярных проектах на языке Java, код которых находится в открытом доступе.
% Кроме того, на тех же проектах был запущен SpotBugs, чтобы иметь возможность сравнить выдаваемые анализаторами предупреждения.

Перед тем, как запустить статический анализ на каждом из кандидатов, проекты были собраны, то есть их классы были скомпилированы в Java байт-код, который требуется для работы инструмента. Результаты экспериментов описаны в соответствующих подразделах ниже.

\subsubsection{Tape}

Tape \cite{tape} "--- быстрая транзакционная файловая очередь для Java. Проект не очень большой "--- всего пару тысяч строк кода, однако этого вполне достаточно для целей тестирования.

В результате запуска анализатора был сгенерирован отчёт SARIF размером более 5 тысяч строк, в котором было подробно описано 50 обнаруженных проблем.

\begin{itemize}
    \item \verb|NullPointerException| "--- возникал 37 раз.
    \item \verb|IOException| "--- 10 раз.
    \item \verb|NegativeArraySizeException| "--- 2 раза.
    \item \verb|NoSuchElementException| "--- только 1 раз.
\end{itemize}

Важно отметить, что некоторые найденные ошибки, особенно, большое количество разыменований нулевого указателя, могут никогда не проявиться при реальном использовании Tape. Проблема возникает, если передавать в публичные методы классов <<некорректные>> значения аргументов, то есть не соблюдать негласные договорённости между пользователем и разработчиком библиотеки. Основной недостаток таких неявных соглашений заключается в том, что пользователи, а то и сам разработчик через какое-то время после написания кода, могут случайно забыть их выполнить и, как следствие, получить неправильное поведение программы. Статический анализатор отлавливает такие ситуации и сообщает о них.

Например, в проекте есть метод \verb|void add(T entry)|, разработчик которого неявно подразумевал, что в его метод никто не передаст значение \verb|null|, ведь иначе будет выброшено исключение \verb|NullPointerException|. Однако UnitTestBot сгенерировал тестовый случай, где \verb|entry| равняется \verb|null|, а также добавил в отчёт статического анализа этот тест как ошибку. В данном случае, разработчику стоило пометить \verb|entry| аннотацией \verb|@NotNull|, что решило бы описанную проблему.

Похожий пример возник в методе \verb|void remove(int n)|. UnitTestBot обнаружил, что его запуск с аргументом \verb|n = 131072| приводит к выбрасыванию исключения \verb|NoSuchElementException|. Здесь возможны два варианта. Первый состоит в том, что автор библиотеки не знал о таком сценарии, а значит инструмент действительно нашёл допущенную ошибку. Второй "--- он знал, но по какой-то причине не воспользовался стандартным способом документирования потенциальных исключений и не добавил строку \verb|throws NoSuchElementException| в объявление функции. В этом случае поведение анализатора тоже ожидаемо "--- выданным сообщением об ошибке он подсказал разработчику задокументировать поведение метода во избежание проблем в будущем.

% \subsubsection{Ttorrent}

% Ttorrent \cite{ttorrent} "--- это популярная реализация протокола BitTorrent на языке Java, предоставляющая трекер и клиент BitTorrent и связанные с ним возможности создания и анализа файлов Torrent. Проект имеет гораздо более внушительную кодовую базу по сравнению с предыдущим "--- около 16 тысяч строк.

% В результате запуска статического анализа для всех классов был сгенерирован отчёт SARIF размером более 30 тысяч строк, в котором было подробно описано 335 обнаруженных проблем. Большинство из них "--- это разыменования нулевого указателя (308 предупреждений) и выход за границы массива (14 предупреждений). Среди остальных сообщений, есть те, которых не было найдено в Tape "--- \verb|ArithmeticException| и \verb|StackOverflowError|.

\subsubsection{Fastjson}

Fastjson \cite{fastjson} "--- высокопроизводительная библиотека, которая используется для преобразования объектов Java в их JSON представление. Проект имеет гораздо более внушительную кодовую базу по сравнению с предыдущим "--- около 50 тысяч строк.

По итогам анализа, было обнаружено 1121 проблема, среди которых 830 разыменований нулевого указателя и 193 выхода за границы массива. Также было найдено 75 \verb|JSONException| и 10 \verb|JSONPathException|, что показывает способность инструмента работать с пользовательскими исключениями, определёнными непосредственно в анализируемом проекте.

% \subsubsection{Другие}

% Для полноты проводимого тестирования были взяты ещё два проекта: SLF4J \cite{slf4j} и Logback \cite{logback} "--- известные библиотеки для журналирования на Java. Их результаты, а также результаты кандидатов, описанных выше, представлены в таблице \ref{table-testing-results}. Строки отсортированы по объёму кода, остальные колонки содержат количество найденных исключений: NPE "--- разыменования нулевого указателя (\verb|NullPointerException|), IOBE "--- выход за границы массива или строки (\verb|IndexOutOfBoundsException|).

% \subsubsection{Результаты}

% Результаты тестирования кандидатов представлены в таблице \ref{table-testing-results}. Строки отсортированы по объёму кода, остальные колонки содержат количество найденных исключений: NPE "--- разыменования нулевого указателя (\verb|NullPointerException|), IOBE "--- выход за границы массива или строки (\verb|IndexOutOfBoundsException|).

% \begin{table}[ht]
% \begin{center}
% \begin{tabular}{lccccc}
%     Название & Строк кода (тыс.) & NPE & IOBE & Другие & Всего \\
% \hline
%     Tape     &  2 & 37 & 0 & 13 & 50 \\
%     Ttorrent & 16 & 308 & 14 & 13 & 335 \\
%     SLF4J    & 19 & 169 & 3 & 2 & 174 \\
%     Fastjson & 56 & 830 & 187 & 104 & 1121 \\
%     Logback  & 58 & 579 & 18 & 13 & 610 \\
% \end{tabular}
% \caption{
% \label{table-testing-results} Результаты тестирования на больших проектах.}
% \end{center}
% \end{table}

% Видим, что количество обнаруженных проблем не полностью зависит от размера проекта, а значит есть как минимум ещё один фактор, влияющий на результат. Возможно, это <<сложность>> кода, другими словами, чем более низкоуровневый код, тем вероятнее, что в нём допущены ошибки. В библиотеках для журналирования такого меньше, поэтому и дефектов там было найдено меньше, чем в сравнимых по размеру кандидатах.

\subsection{Запуск на задачах Codeforces}

На больших проектах сложно оценить серьёзность находимых ошибок, ведь для этого нужно, во-первых, хорошо разбираться в самом проекте, а во-вторых, вручную проанализировать каждый выдаваемый результат, что очень трудозатратно. Поэтому, чтобы оценить насколько неочевидные проблемы способен находить анализатор, были проведены дополнительные эксперименты на решениях задач с CodeForces \cite{codeforces}. 

В ходе работы было рассмотрено более 100 задач по программированию и алгоритмам. Для каждой из них, были изучены отправленные в систему решения на языке Java, которые не прошли тестирование по причине выброшенного исключения (вердикт <<Ошибка исполнения>>). Из всех посылок были отобраны только 23, на которых и планировалось запустить статический анализ. В выборку включались программы, требующие глубокого анализа, так как допущенная в них ошибка не была очевидна. Отметим также, что на сайте CodeForces не раскрывается конкретный тестовый случай, на котором провалилось решение, поэтому для программиста может быть полезно найти его с помощью UnitTestBot.

В условиях задач обычно устанавливаются ограничения на входные данные, на которые может опираться отправляемая в систему программа. Поэтому, чтобы эффективно анализировать код, нужно сначала привести его к следующему виду.

\begin{code}
public class Main {

    static /* тип ответа */ solve(/* ... */) {
        assume(/* ограничения в виде предиката */);
        // само решение
    }

    public static void main(String[] args) {
        // ввод данных
        var result = solve(/* входные данные */);
        // вывод ответа
    }
}
\end{code}

Статический анализ запускался только на функции \verb|solve|, которая уже не занимается чтением входных данных и печатью результата. В ней вызывается специальный метод \verb|assume| инструмента UnitTestBot, позволяющий наложить определённые ограничения на символьные переменные. В данном случае это нужно как раз для учёта ограничений из условия задачи. 

Описанное преобразование кода нужно было вручную проделать для каждой из 23 выбранных посылок. В результате анализа, для 10 из 23 программ удалось обнаружить тестовый случай, приводящий к выбрасыванию исключения.

Отметим, что неправильные посылки специально подбирались так, чтобы допущенные в них ошибки не повторяли друг друга. Таким образом, получилось проверить анализатор на способность находить различные дефекты. Были выявлены такие проблемы, как деление на ноль, разыменование нулевого указателя, переполнение стека и выход за границы массива или строки "--- часто возникающие исключения в коде на Java.

Рассмотрим одну из успешно найденных ошибок. Соответствующая посылка, а точнее, уже отредактированная по шаблону функция \verb|solve|, представлена в листинге \ref{cf-example}. Решение было отправлено по задаче B соревнования <<Codeforces Round 805>> \cite{cf-805B}. Смотря на код решения, совершенно неочевидно, какая в нём есть проблема, где она возникает и как её воспроизвести. Однако статический анализатор даёт ответы на все эти вопросы, возвращая предупреждение на строку 24, в котором указан искомый тестовый случай "--- \verb|solve("ac")|.

\begin{zerocode}
"Unexpected StringIndexOutOfBoundsException:
     String index out of range: 2.
 Test case: solve(ac)."
\end{zerocode}
